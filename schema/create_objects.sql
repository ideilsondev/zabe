-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.services (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL UNIQUE,
  description text,
  services jsonb NOT NULL DEFAULT '{}'::jsonb
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid PRIMARY KEY,
  name text NOT NULL,
  role text DEFAULT 'user' NOT NULL,
  status text DEFAULT 'active',
  default_tenant_id bigint,
  inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.tenants (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code bigint NOT NULL UNIQUE,
  name text NOT NULL,
  owner_id uuid REFERENCES public.profiles(id) ON DELETE
  SET NULL,
    status text DEFAULT 'active',
    inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
    updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
);
ALTER TABLE public.profiles
ADD CONSTRAINT fk_default_tenant_id FOREIGN KEY (default_tenant_id) REFERENCES public.tenants(id) ON DELETE
SET NULL;
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.user_tenants (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
  role text NOT NULL,
  status text DEFAULT 'pending',
  permissions jsonb NOT NULL DEFAULT '[]'::jsonb,
  inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  UNIQUE(user_id, tenant_id)
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.tenant_groups (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
  name text NOT NULL,
  permissions jsonb NOT NULL DEFAULT '[]'::jsonb,
  inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  UNIQUE(tenant_id, name)
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.user_tenant_groups (
  user_id uuid NOT NULL,
  group_id bigint NOT NULL,
  tenant_code bigint NOT NULL,
  PRIMARY KEY (user_id, group_id),
  CONSTRAINT fk_user_tenant FOREIGN KEY (user_id, tenant_code) REFERENCES public.user_tenants (user_id, tenant_code) ON DELETE CASCADE,
  CONSTRAINT fk_group FOREIGN KEY (group_id) REFERENCES public.tenant_groups (code) ON DELETE CASCADE
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.blocked_users (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL UNIQUE REFERENCES public.profiles(id) ON DELETE CASCADE,
  reason text NOT NULL,
  blocked_by uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  blocked_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
);
-- =================================================================
-- Remoção de Tabelas de Informações do Tenant: 
-- As tabelas tenant_characteristics, addresses, contacts e bank_accounts, tenant_types 
-- foram completamente removidas. a referência ao tenant será apenas um name (para exibição) e um code (vindo do CRM).
-- Isso elimina massivamente a coleta de dados pessoais e sensíveis (CPF, CNPJ, endereços, telefones, dados bancários).
-- =================================================================
-- CREATE TABLE IF NOT EXISTS public.tenant_characteristics (
--   id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--   tenant_id bigint NOT NULL UNIQUE REFERENCES public.tenants(id) ON DELETE CASCADE,
--   tenant_type_id smallint NOT NULL REFERENCES public.tenant_types(id) ON DELETE RESTRICT,
--   legal_name text,
--   trade_name text,
--   document_type text NOT NULL,
--   document_number text NOT NULL,
--   inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
--   updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
-- );
-- =================================================================
-- CREATE TABLE IF NOT EXISTS public.addresses (
--   id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--   tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
--   address_type text NOT NULL,
--   street text NOT NULL,
--   number text,
--   neighborhood text NOT NULL,
--   city text NOT NULL,
--   state text NOT NULL,
--   zip_code text NOT NULL,
--   is_primary boolean DEFAULT false,
--   inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
--   updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
-- );
-- =================================================================
-- CREATE TABLE IF NOT EXISTS public.contacts (
--   id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--   tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
--   contact_type text NOT NULL,
--   value text NOT NULL,
--   is_primary boolean DEFAULT false,
--   inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
--   updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
-- );
-- =================================================================
-- CREATE TABLE IF NOT EXISTS public.bank_accounts (
--   id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--   tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
--   bank_code text NOT NULL,
--   agency_number text NOT NULL,
--   account_number text NOT NULL,
--   account_digit text NOT NULL,
--   is_primary boolean DEFAULT false,
--   inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
--   updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
-- );
-- =================================================================
-- CREATE TABLE IF NOT EXISTS public.tenant_types (
--   id smallint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--   name text NOT NULL UNIQUE,
--   description text,
--   inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
-- );
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.sectors (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
  name text NOT NULL,
  description text,
  inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  UNIQUE(tenant_id, name)
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.devices (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
  code bigint NOT NULL UNIQUE,
  mac text NOT NULL UNIQUE,
  name text NOT NULL,
  status text DEFAULT 'active',
  last_seen timestamptz,
  inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.tags (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code text NOT NULL UNIQUE,
  tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
  device_code bigint REFERENCES public.devices(code) ON DELETE
  SET NULL,
    name text NOT NULL DEFAULT 'tag',
    protocol text NOT NULL,
    params jsonb NOT NULL DEFAULT '{}'::jsonb,
    status text DEFAULT 'active',
    settings jsonb NOT NULL,
    description text,
    inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
    updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
    UNIQUE(tenant_id, name)
);
-- =================================================================
-- Motivo da solicitação, o dispositivo que vai executar a coleta
-- ele pode gerar tags coi id diferentes, oque pode provocar desvio de leituras
-- foi adicionado a leitura  o tenant_id, assim blindando a esposição de leituras
-- =================================================================
CREATE TABLE IF NOT EXISTS public.readings (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code text NOT NULL UNIQUE,
  -- este campo de ve ser criado para a plataforma saber saber extamente qual a leitura vinda do equipamento, esse vaor vai ser gerado no chao de fabrica, podemos usar uma formaque mesmo esse valor gerado la no chao ele nao conflite com lituras na nuvem
  tag_code text NOT NULL,
  --
  tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
  is_test boolean DEFAULT false,
  -- este campo vai ser referencia se a leitura é de teste ou produção, vai ser preciso criar uma função para apagar todas as leituras de test quando o uma campo no tenant for alterado, exmpo um campo que descreva se o tenant ja esta coletando oficialmente, ou os dados coletados sao para o processo de calibração da plataforma
  device_mac text REFERENCES public.devices(mac) ON DELETE
  SET NULL,
    timestamp timestamptz NOT NULL DEFAULT timezone('utc', now()),
    value jsonb NOT NULL,
    -- este campo foi alterado para jsonb devido a naturesa das leitura que podem variar o seu formato, inteiro, string, bool, etc.
    inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
    -- informações criado na nuvem porem precisamos armazenar hora 
    updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL -- informações criada na nuvem
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.vehicles (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
  placa text NOT NULL UNIQUE,
  capacidade_toneladas numeric,
  tipo text,
  status text DEFAULT 'active',
  inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.readers (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
  sector_id bigint REFERENCES public.sectors(id) ON DELETE
  SET NULL,
    name text NOT NULL,
    type text NOT NULL,
    status text DEFAULT 'active',
    inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
    updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.trips (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_code bigint NOT NULL REFERENCES public.tenants(code) ON DELETE CASCADE,
  vehicle_id bigint NOT NULL REFERENCES public.vehicles(id) ON DELETE RESTRICT,
  reader_id_in bigint REFERENCES public.readers(id) ON DELETE
  SET NULL,
    reader_id_out bigint REFERENCES public.readers(id) ON DELETE
  SET NULL,
    timestamp_in timestamptz,
    timestamp_out timestamptz,
    peso_in numeric,
    peso_out numeric,
    status text DEFAULT 'waiting',
    notes text,
    setor_id bigint REFERENCES public.sectors(id) ON DELETE
  SET NULL,
    inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
    updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.dashboards (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_id bigint NOT NULL UNIQUE REFERENCES public.tenants(id) ON DELETE CASCADE,
  configs jsonb NOT NULL,
  inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.audit_logs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  action text NOT NULL,
  user_id uuid,
  tenant_id bigint,
  details jsonb,
  timestamp timestamptz DEFAULT timezone('utc', now()) NOT NULL
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.sessions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sector_id bigint NOT NULL REFERENCES public.sectors(id) ON DELETE CASCADE,
  name text NOT NULL,
  description text,
  inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  UNIQUE(sector_id, name)
);
-- =================================================================
-- ESTRUTURA DE TABELAS COMPLETA
-- =================================================================
CREATE TABLE IF NOT EXISTS public.indicators (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id bigint NOT NULL REFERENCES public.sessions(id) ON DELETE CASCADE,
  name text NOT NULL,
  formula_json jsonb NOT NULL,
  unit text,
  inserted_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  updated_at timestamptz DEFAULT timezone('utc', now()) NOT NULL,
  UNIQUE(session_id, name)
);
-- =================================================================
-- SEÇÃO DE FUNÇÕES
-- =================================================================
-- CREATE OR REPLACE FUNCTION public.generate_tenant_code() RETURNS TEXT LANGUAGE plpgsql AS $$ BEGIN RETURN upper(substring(md5(random()::text), 1, 9));
-- END;
-- $$;
-- ALTER TABLE public.tenants
-- ALTER COLUMN code
-- SET DEFAULT public.generate_tenant_code();
-- nova função que retorna um BIGINT baseado no timestamp.
CREATE OR REPLACE FUNCTION public.generate_numeric_code() RETURNS BIGINT LANGUAGE plpgsql AS $$
DECLARE v_epoch_ms BIGINT;
v_random_suffix INT;
v_result BIGINT;
BEGIN -- Pega os milissegundos da época atual
SELECT floor(
    extract(
      EPOCH
      FROM clock_timestamp()
    ) * 1000
  ) INTO v_epoch_ms;
-- Gera um número aleatório de 3 dígitos para evitar colisões
SELECT floor(random() * 900 + 100)::INT INTO v_random_suffix;
-- Concatena os milissegundos com o sufixo aleatório
-- Ex: 1678886400123 & 456 -> 1678886400123456
v_result := (v_epoch_ms * 1000) + v_random_suffix;
RETURN v_result;
END;
$$;
-- Aplica a nova função como o valor padrão para a coluna 'code'.
ALTER TABLE public.tenants
ALTER COLUMN code
SET DEFAULT public.generate_numeric_code();
ALTER TABLE public.tags
ALTER COLUMN code
SET DEFAULT public.generate_numeric_code();
CREATE OR REPLACE FUNCTION public.update_updated_at() RETURNS TRIGGER LANGUAGE plpgsql AS $$ BEGIN NEW.updated_at := timezone('utc', now());
RETURN NEW;
END;
$$;
CREATE OR REPLACE FUNCTION public.get_current_user_role() RETURNS TEXT LANGUAGE plpgsql SECURITY DEFINER STABLE AS $$
DECLARE user_role TEXT;
BEGIN
SELECT role INTO user_role
FROM public.profiles
WHERE id = auth.uid();
RETURN COALESCE(user_role, 'user');
END;
$$;
CREATE OR REPLACE FUNCTION public.get_role_level(role_text TEXT) RETURNS INTEGER LANGUAGE plpgsql IMMUTABLE AS $$ BEGIN RETURN CASE
    role_text
    WHEN 'user' THEN 1
    WHEN 'system' THEN 2
    WHEN 'manager' THEN 3
    WHEN 'admin' THEN 4
    WHEN 'owner' THEN 5
    ELSE 0
  END;
END;
$$;
CREATE OR REPLACE FUNCTION public.is_higher_role(target_role TEXT) RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER STABLE AS $$
DECLARE current_level INT;
target_level INT;
BEGIN current_level := public.get_role_level(public.get_current_user_role());
target_level := public.get_role_level(target_role);
RETURN target_level > current_level;
END;
$$;
CREATE OR REPLACE FUNCTION public.create_profile_for_new_user() RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER
SET search_path = public AS $$ BEGIN
INSERT INTO public.profiles (id, name, role, status)
VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', NEW.email),
    'user',
    'active'
  );
RETURN NEW;
END;
$$;
CREATE OR REPLACE FUNCTION public.get_user_permissions(p_user_id uuid, p_tenant_id bigint) RETURNS text [] LANGUAGE sql SECURITY DEFINER STABLE AS $$
SELECT COALESCE(ARRAY_AGG(DISTINCT permission), '{}'::text [])
FROM (
    SELECT jsonb_array_elements_text(permissions) AS permission
    FROM public.user_tenants
    WHERE user_id = p_user_id
      AND tenant_id = p_tenant_id
      AND permissions IS NOT NULL
    UNION ALL
    SELECT jsonb_array_elements_text(tg.permissions) AS permission
    FROM public.user_tenant_groups utg
      JOIN public.tenant_groups tg ON utg.group_id = tg.id
    WHERE utg.user_id = p_user_id
      AND tg.tenant_id = p_tenant_id
  ) AS all_permissions;
$$;
CREATE OR REPLACE FUNCTION public.check_permission(p_tenant_id bigint, p_required_permission text) RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER STABLE AS $$
DECLARE v_user_id uuid := auth.uid();
v_tenant_role text;
v_user_permissions text [];
BEGIN IF p_tenant_id IS NULL THEN RETURN false;
END IF;
SELECT role INTO v_tenant_role
FROM public.user_tenants
WHERE user_id = v_user_id
  AND tenant_id = p_tenant_id
  AND status = 'active';
IF NOT FOUND THEN RETURN false;
END IF;
IF v_tenant_role IN ('manager', 'admin', 'owner') THEN RETURN true;
END IF;
IF v_tenant_role = 'user' THEN v_user_permissions := public.get_user_permissions(v_user_id, p_tenant_id);
RETURN (
  p_required_permission = ANY(v_user_permissions)
  OR 'all' = ANY(v_user_permissions)
);
END IF;
RETURN false;
END;
$$;
CREATE OR REPLACE FUNCTION public.fn_audit_trigger() RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER
SET search_path = public AS $$
DECLARE v_old_data jsonb;
v_new_data jsonb;
v_tenant_id bigint;
BEGIN IF (
  TG_OP = 'INSERT'
  OR TG_OP = 'UPDATE'
) THEN v_tenant_id := (to_jsonb(NEW)->>'tenant_id')::bigint;
ELSE v_tenant_id := (to_jsonb(OLD)->>'tenant_id')::bigint;
END IF;
v_old_data := CASE
  WHEN (
    TG_OP = 'UPDATE'
    OR TG_OP = 'DELETE'
  ) THEN to_jsonb(OLD)
  ELSE NULL
END;
v_new_data := CASE
  WHEN (
    TG_OP = 'INSERT'
    OR TG_OP = 'UPDATE'
  ) THEN to_jsonb(NEW)
  ELSE NULL
END;
INSERT INTO public.audit_logs (action, user_id, tenant_id, details)
VALUES (
    TG_OP,
    auth.uid(),
    v_tenant_id,
    jsonb_build_object(
      'table',
      TG_TABLE_NAME,
      'old_data',
      v_old_data,
      'new_data',
      v_new_data
    )
  );
RETURN COALESCE(NEW, OLD);
END;
$$;
-- =================================================================
-- HABILITAR RLS, CRIAR POLICIES E TRIGGERS
-- =================================================================
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tenant_groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_tenant_groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.blocked_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tenant_characteristics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.addresses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bank_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sectors ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.devices ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.readings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.vehicles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.readers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trips ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.dashboards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.indicators ENABLE ROW LEVEL SECURITY;
-- Policies para Tabelas de Sistema
CREATE POLICY "Profiles: Full access for owners/admins" ON public.profiles FOR ALL USING (get_current_user_role() IN ('owner', 'admin')) WITH CHECK (get_current_user_role() IN ('owner', 'admin'));
CREATE POLICY "Profiles: Users can read/update own profile" ON public.profiles FOR ALL USING (id = auth.uid()) WITH CHECK (id = auth.uid());
CREATE POLICY "Tenants: Members can read" ON public.tenants FOR
SELECT USING (check_permission(id, 'tenant.read'));
CREATE POLICY "Tenants: Admins can manage" ON public.tenants FOR ALL USING (check_permission(id, 'tenant.manage'));
CREATE POLICY "UserTenants: Admins can manage bindings" ON public.user_tenants FOR ALL USING (check_permission(tenant_id, 'users.manage'));
CREATE POLICY "UserTenants: Users can see own bindings" ON public.user_tenants FOR
SELECT USING (user_id = auth.uid());
CREATE POLICY "TenantGroups: Admins can manage" ON public.tenant_groups FOR ALL USING (check_permission(tenant_id, 'groups.manage'));
CREATE POLICY "TenantGroups: Members can read" ON public.tenant_groups FOR
SELECT USING (check_permission(tenant_id, 'groups.read'));
CREATE POLICY "UserTenantGroups: Admins can manage bindings" ON public.user_tenant_groups FOR ALL USING (check_permission(tenant_id, 'groups.manage'));
CREATE POLICY "BlockedUsers: Admins can manage" ON public.blocked_users FOR ALL USING (get_current_user_role() IN ('owner', 'admin'));
-- Policies para Tabelas de Informações do Tenant
CREATE POLICY "TenantInfo: Admins can manage characteristics" ON public.tenant_characteristics FOR ALL USING (check_permission(tenant_id, 'tenant.manage'));
CREATE POLICY "TenantInfo: Members can read addresses" ON public.addresses FOR
SELECT USING (check_permission(tenant_id, 'addresses.read'));
CREATE POLICY "TenantInfo: Admins can manage addresses" ON public.addresses FOR ALL USING (check_permission(tenant_id, 'addresses.manage'));
CREATE POLICY "TenantInfo: Members can read contacts" ON public.contacts FOR
SELECT USING (check_permission(tenant_id, 'contacts.read'));
CREATE POLICY "TenantInfo: Admins can manage contacts" ON public.contacts FOR ALL USING (check_permission(tenant_id, 'contacts.manage'));
CREATE POLICY "TenantInfo: Finance users can read bank accounts" ON public.bank_accounts FOR
SELECT USING (check_permission(tenant_id, 'finance.read'));
CREATE POLICY "TenantInfo: Finance admins can manage bank accounts" ON public.bank_accounts FOR ALL USING (check_permission(tenant_id, 'finance.manage'));
-- Policies para Tabelas de Negócio
CREATE POLICY "Business: Admins can manage sectors" ON public.sectors FOR ALL USING (check_permission(tenant_id, 'sectors.manage'));
CREATE POLICY "Business: Members can read sectors" ON public.sectors FOR
SELECT USING (check_permission(tenant_id, 'sectors.read'));
CREATE POLICY "Business: Admins can manage devices" ON public.devices FOR ALL USING (check_permission(tenant_id, 'devices.manage'));
CREATE POLICY "Business: Members can read devices" ON public.devices FOR
SELECT USING (check_permission(tenant_id, 'devices.read'));
CREATE POLICY "Business: Admins can manage tags" ON public.tags FOR ALL USING (check_permission(tenant_id, 'tags.manage'));
CREATE POLICY "Business: Members can read tags" ON public.tags FOR
SELECT USING (check_permission(tenant_id, 'tags.read'));
CREATE POLICY "Business: Members can read readings" ON public.readings FOR
SELECT USING (
    check_permission(
      (
        SELECT tenant_id
        FROM public.tags
        WHERE id = readings.tag_id
      ),
      'readings.read'
    )
  );
CREATE POLICY "Business: Admins can manage vehicles" ON public.vehicles FOR ALL USING (check_permission(tenant_id, 'vehicles.manage'));
CREATE POLICY "Business: Members can read vehicles" ON public.vehicles FOR
SELECT USING (check_permission(tenant_id, 'vehicles.read'));
CREATE POLICY "Business: Admins can manage readers" ON public.readers FOR ALL USING (check_permission(tenant_id, 'readers.manage'));
CREATE POLICY "Business: Members can read readers" ON public.readers FOR
SELECT USING (check_permission(tenant_id, 'readers.read'));
CREATE POLICY "Business: Operators can use trips" ON public.trips FOR ALL USING (check_permission(tenant_id, 'trips.operate'));
CREATE POLICY "Business: Members can read trips" ON public.trips FOR
SELECT USING (check_permission(tenant_id, 'trips.read'));
CREATE POLICY "Business: Admins can manage dashboards" ON public.dashboards FOR ALL USING (check_permission(tenant_id, 'dashboards.manage'));
CREATE POLICY "Business: Members can read dashboards" ON public.dashboards FOR
SELECT USING (check_permission(tenant_id, 'dashboards.read'));
CREATE POLICY "Business: Members can read sessions" ON public.sessions FOR
SELECT USING (
    check_permission(
      (
        SELECT tenant_id
        FROM public.sectors s
        WHERE s.id = sessions.sector_id
      ),
      'sessions.read'
    )
  );
CREATE POLICY "Business: Admins can manage sessions" ON public.sessions FOR ALL USING (
  check_permission(
    (
      SELECT tenant_id
      FROM public.sectors s
      WHERE s.id = sessions.sector_id
    ),
    'sessions.manage'
  )
);
CREATE POLICY "Business: Members can read indicators" ON public.indicators FOR
SELECT USING (
    check_permission(
      (
        SELECT s.tenant_id
        FROM public.sessions ss
          JOIN public.sectors s ON ss.sector_id = s.id
        WHERE ss.id = indicators.session_id
      ),
      'indicators.read'
    )
  );
CREATE POLICY "Business: Admins can manage indicators" ON public.indicators FOR ALL USING (
  check_permission(
    (
      SELECT s.tenant_id
      FROM public.sessions ss
        JOIN public.sectors s ON ss.sector_id = s.id
      WHERE ss.id = indicators.session_id
    ),
    'indicators.manage'
  )
);
CREATE POLICY "Audit: System can insert logs" ON public.audit_logs FOR
INSERT WITH CHECK (true);
CREATE POLICY "Audit: Admins can read logs" ON public.audit_logs FOR
SELECT USING (check_permission(tenant_id, 'audit.read'));
-- Triggers
CREATE TRIGGER on_auth_user_created
AFTER
INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.create_profile_for_new_user();
-- Triggers de 'updated_at'
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.tenants FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.user_tenants FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.tenant_groups FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.tenant_characteristics FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.addresses FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.contacts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.bank_accounts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.sectors FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.devices FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.tags FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.readings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.vehicles FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.readers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.trips FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.dashboards FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.sessions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
CREATE TRIGGER handle_updated_at BEFORE
UPDATE ON public.indicators FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
-- Triggers de Auditoria (ativados para tabelas críticas)
CREATE TRIGGER audit_trigger
AFTER
INSERT
  OR
UPDATE
  OR DELETE ON public.tenant_characteristics FOR EACH ROW EXECUTE FUNCTION public.fn_audit_trigger();
CREATE TRIGGER audit_trigger
AFTER
INSERT
  OR
UPDATE
  OR DELETE ON public.devices FOR EACH ROW EXECUTE FUNCTION public.fn_audit_trigger();
CREATE TRIGGER audit_trigger
AFTER
INSERT
  OR
UPDATE
  OR DELETE ON public.tags FOR EACH ROW EXECUTE FUNCTION public.fn_audit_trigger();
CREATE TRIGGER audit_trigger
AFTER
INSERT
  OR
UPDATE
  OR DELETE ON public.vehicles FOR EACH ROW EXECUTE FUNCTION public.fn_audit_trigger();
CREATE TRIGGER audit_trigger
AFTER
INSERT
  OR
UPDATE
  OR DELETE ON public.trips FOR EACH ROW EXECUTE FUNCTION public.fn_audit_trigger();
CREATE TRIGGER audit_trigger
AFTER
INSERT
  OR
UPDATE
  OR DELETE ON public.user_tenants FOR EACH ROW EXECUTE FUNCTION public.fn_audit_trigger();
CREATE TRIGGER audit_trigger
AFTER
INSERT
  OR
UPDATE
  OR DELETE ON public.tenant_groups FOR EACH ROW EXECUTE FUNCTION public.fn_audit_trigger();
-- =================================================================
-- Índices críticos para consultas frequentes
-- =================================================================
CREATE INDEX IF NOT EXISTS idx_readings_tag_timestamp ON readings (tag_id, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_trips_tenant_status ON trips (tenant_id, status, timestamp_in DESC);
CREATE INDEX IF NOT EXISTS idx_user_tenants_composite ON user_tenants (user_id, tenant_id, status);
CREATE INDEX IF NOT EXISTS idx_audit_logs_tenant_timestamp ON audit_logs (tenant_id, timestamp DESC);
-- =================================================================
-- DADOS INICIAIS
-- =================================================================
INSERT INTO public.tenant_types (name, description)
VALUES ('individual', 'Pessoa Física'),
  ('company', 'Pessoa Jurídica/Empresa') ON CONFLICT (name) DO NOTHING;